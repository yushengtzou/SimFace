/*
TERMS OF NON-COMMERCIAL USE    

NON-COMMERCIAL USE ONLY: By downloading this software you agree to use the software contained herein for internal, non-commercial research, evaluation or testing purposes only. Any use of the data generated by the software or its contents to manufacture or sell products or technologies (or portions thereof) either directly or indirectly for any direct or indirect for-profit purposes is strictly prohibited. Subject to the above conditions, this software is provided under the BSD-3 license, a copy of which is contained with the source or object code files downloaded. 

CITATION: By downloading this software you agree to reference the publication Skin Microstructure Deformation with Displacement Map Convolution (http://gl.ict.usc.edu/Research/SkinStretch/) and acknowledge Koki Nagano, Graham Fyffe, Oleg Alexander, Jernej Barbic, Hao Li, Abhijeet Ghosh, and Paul Debevec as the source of the software and any data generated in any publications reporting use of it or any manual or document. A copy of all reports and papers that are for public or general release that use the data generated must be forwarded immediately upon release or publication to Kathleen Haase (Haase@ict.usc.edu).
*/

//version 1.0
//2017.03.22
//Koki Nagano
//koki.nagano0219@gmail.com
//GLSL shader to compute per-pixel anisotropic stretch


#extension GL_EXT_gpu_shader4 : enable
#define pi 3.1415926535897932384626433832795
/*
** varying 
*/
varying vec2 Tr0;//1st row of T
varying vec2 Tr1;//2nd row of T
/*
** uniform 
*/
uniform sampler2D maskSampler;//optionally use mask. When mask is 0.0, keep the stretch ratio neutral (convolution won't do anything)

//[REF]: Jim Blinn's Corner: Notation, Notation, Notation
//or http://scicomp.stackexchange.com/questions/8899/robust-algorithm-for-2x2-svd
void main (void)
{
	//mij, is (i,j) entry of T matrix in equation (10)
    float m00 = Tr0.x;
    float m01 = Tr0.y;
    float m10 = Tr1.x;
    float m11 = Tr1.y;
    float E = (m00+m11)/2.0;
    float F = (m00-m11)/2.0;
    float G = (m10+m01)/2.0;
    float H = (m10-m01)/2.0;
    float Q = sqrt(E*E + H*H);
    float R = sqrt(F*F + G*G);
    float sx = Q+R;
    float sy = Q-R;
    float a1 = atan(G, F);
    float a2 = atan(H, E);
    float theta = (a2-a1)/2.0;
    float phi = (a2+a1)/2.0;
    vec2 uv = gl_TexCoord[0].st;
    float mask = texture2D(maskSampler, uv).r;
	sx = mask * sx + (1.0-mask) * 1.0;
    sy = mask * sy + (1.0-mask) * 1.0;
    theta = mask * theta;

	//return (R,G,B) = (Major stress, Minor stress, Major Angle)
	gl_FragColor = vec4(sx, sy, theta, 1.0);
}
