/*
TERMS OF NON-COMMERCIAL USE    

NON-COMMERCIAL USE ONLY: By downloading this software you agree to use the software contained herein for internal, non-commercial research, evaluation or testing purposes only. Any use of the data generated by the software or its contents to manufacture or sell products or technologies (or portions thereof) either directly or indirectly for any direct or indirect for-profit purposes is strictly prohibited. Subject to the above conditions, this software is provided under the BSD-3 license, a copy of which is contained with the source or object code files downloaded. 

CITATION: By downloading this software you agree to reference the publication Skin Microstructure Deformation with Displacement Map Convolution (http://gl.ict.usc.edu/Research/SkinStretch/) and acknowledge Koki Nagano, Graham Fyffe, Oleg Alexander, Jernej Barbic, Hao Li, Abhijeet Ghosh, and Paul Debevec as the source of the software and any data generated in any publications reporting use of it or any manual or document. A copy of all reports and papers that are for public or general release that use the data generated must be forwarded immediately upon release or publication to Kathleen Haase (Haase@ict.usc.edu).
*/

//version 1.0
//2017.03.22
//Koki Nagano
//koki.nagano0219@gmail.com
//GLSL shader to perform displacement map convolution.

#extension GL_EXT_gpu_shader4 : enable
#define pi 3.1415926535897932384626433832795
#pragma optionNV(inline all)
#pragma optionNV(unroll all)

//number of pixels you blur/sharpen
#define N 31

/*
** varying 
*/

//V in equation (13) captures the angle of the stretching (rotation), and 
//QR^t (or the rotation factored component of Q) there merely serves for conversion factor 
//to convert world scale to UV. So we only pass in such scalars.
varying vec2 MagQRt;

/*
** uniform 
*/
uniform sampler2D stressMap;//pre-computed perpixel stress/angle map (R,G,B) = (Major stress, Minor stress, Major Angle)
uniform sampler2D dispSampler;//input displacement to be convolved
uniform int isStretching;//flag to switch on/off dynamic displacement
uniform int secondAxis;//flag if we are processing major or minor axis

float computeGaussian(float sigma, float x)
{
	float xs = x / sigma;
	return exp(-0.5*xs*xs);
}

void main (void)
{
	vec2 uv = gl_TexCoord[0].st;

	vec2 aniso_stretch = texture2D(stressMap, uv).rg;//major/minor stress
	float angle = texture2D(stressMap, uv).b;//major axis angle

	float s;//stretch

	//Optioinally increase or decrease stretch/compression
	//default is zero for both
	const float stretchBoost = 0.1;
	const float compressionBoost = 0.1;
	if(secondAxis == 1) 
	{
		//because we store major axis angle, 
		//rotate it by 90 degrees to make it minor axis, which is orthogonal to major one
		angle += pi/2.0;
		s = aniso_stretch.y * (1.0 - compressionBoost);
	}
	else
	{
		s = aniso_stretch.x * (1.0 + stretchBoost);
	}

	//[NOTE] for human face, it is reasonable to keep the stretch/compression +/- 30~40% relative to neutral.
	//But this depends on skin condition, ages etc
	//this can be exposed as a control so a user can adjust the value for alien skin etc
	const float maxStretch = 1.40;
	const float maxCompression = 0.7;
	s = max(maxCompression, min(maxStretch, s));

	//This angle is one for Vt so multiply by -1 to get the angle of V matrix 
	angle *= -1.0;

	//reconstruct rotation matrix from major axis angle
	//NOTE: column major
	mat2 V = mat2( cos(angle), sin(angle),
				  -sin(angle), cos(angle));	

	//input displacement
	float disp = texture2D(dispSampler, uv).r;
    float dispDef = 0.0;
	float res;//result

	//equation (8) and (9) from paper "Skin Microstructure Deformation with Displacement Map Convolution"
	//the value is derived from a human face and may be modified for different skin types or non-human skin 
	float alpha = min(1.0, min(15.4*s-13.8, 3.09*(s-1.0)));
	float sigma = s < 1.0 ? max(1.0, 70.5*s-46.9) : 38.2*s-26.5;//in micron

	float numSigma = 2.5;//how many sigmas you want to consider in gaussian blurring
	float micronToCM = 1.0/10000.0;//conversion factor to convert sigma in Micron to OBJ mesh in world in CentiMeter. 1 pixel ~ 10 micron in paper.
	vec2 worldToUV = MagQRt;//Magnitude of QRt (or S) in equation (13) as a conversion factor from world (e.g. cm for light stage data) to UV (0-1 unit). 
	float mask = 1.0;

	//[NOTE] the following performs brute-force gaussian blurrign along stretching axis on every pixel of displacement pixel
	//Replace this for renderer specific or hardware implemented or any better implimentation of anisotripic filters for better runtime performance.
	if(isStretching != 0)
	{
		//Compute Gaussian kernel
		float gaussian[N];
		float sum = 0.0;
		for(int i=0;i<N;i++)
		{
			float x = (i-N/2.0)*numSigma/(N-1.0);
			gaussian[i] = computeGaussian(1.0, x);
			sum += gaussian[i];//normalization factor for blur kernel
		}

		//scale factor to convert sigma in proper unit in UV space
		float conversionFactor;
		//Additional factor: this will influence how far your convolution kernel reach in the texture
		//bigger, the stronger blurring/sharpening
		const float filterBoost = 15.0;
		conversionFactor = micronToCM * filterBoost;
		if(secondAxis==0)
			conversionFactor *= worldToUV.x;
		else
			conversionFactor *= worldToUV.y;


	    for(int i=0;i<N;i++)
		{
            float sx = (i-N/2.0)*numSigma/(N-1.0) * sigma;
			//apply rotation to UV axis to do the convolution on pixels along stretch axis
			vec2 convolutionUV = V * vec2(conversionFactor * sx, 0.0) + uv;
			dispDef += texture2D(dispSampler, convolutionUV).r * ((1.0-alpha)*(i==N/2) + alpha*gaussian[i]/sum);			
		}		
		res = dispDef;
	}
	else
		res = disp;

	gl_FragColor.r = res;	
}
